类：
	类是事物的抽象，一个类有事物的属性和方法，用来具体的描述一个事物，用关键字
	class修饰
	可以有多个类，但是只有一个用关键字public修饰符修饰的类，并且这个类的类
	名必须(最好规范)和文件名一致。
八种基本数据类型：byte、short、int、long、double float、char、boolean  
                    引用数据类型有数组，类，接口
方法：
	用来描述事物行为的就是方法
        方法的组成：权限修饰符，返回值类型，方法名，参数列表，方法体
                public    void       A      (String str)       {}
	方法可以没有返回值，void表示无返回值，方法的返回值类型要根据public后面的关键字决定
方法体：方法被调用时真正被执行的代码
权限修饰符：
	public----公共的，表示在哪里都可以使用对象调用它
	protected----受保护的，表示在同一个包中或者子类中可以使用
	private---私有的，表示只在当前类中使用
	什么都不写表示默认的，只在同一个包中使用
包：
        英文：package
        	包的存在，就是来区分同名的类。
包的命名：公司网址的倒置。保证类同名也不影响。

对象:
	指具体概念的具体个体。
创建一个对象：
	通过new关键字(向堆中申请分配空间)，new 类名()来创建一个对象，此时还需将这个对象
	的地址存放到对象变量中，假设是A a，a也是一个引用，通过这个引用可以找到对象，引用
	存放在栈中的，new 类名()对象是存放在堆中。
匿名对象：
	匿名对象就是在new一个对象时并没有直接的将这个对象的地址传给一个引用，而是直接使用，
	也就是说它没有名字，那么就说这个是匿名对象；
	举例：
		A a=new A();这是一个有引用a的对象不是匿名对象，在使用时直接使用new A()。那么这就是匿名对象
String类：
	表示字符串，字符串String不是数据类型
	字符串是不可变的，一个字符串被创建后就不能再发生改变
	用来比较字符串内容是否相等用equals，不能用==，==比较的是地址是否相等。而equals比较的
	是两个对象的内容是否相等。
	
面向对象的三大特性：
	类的继承：
		关键字extends
		子类可以继承父类的属性和方法，但是并不是子类可以继承父类的所有属性和方法，如果父类的属性或方法
			被关键字private修饰，那么子类就不能继承。
		扩展：如果子类继承了父类的方法和属性，但是又定义了自己独有的属性和方法，那么这就属于扩展。
	
		继承的使用:父类的引用指向了子类的对象，所以可以将父类作为方法的形式参数(形参)，子类作为方法的实际
		(实参)。
	封装：
		封装就是隐藏实现细节，将一个类中的属性私有化(private)，只对外提供公共的访问方法，实现对数据访问
		限制，提高程序的可维护性。
	多态：父类的引用指向了子类的对象；接口的引用指向了它的实现类的对象
		多态存在的三个必要条件
			1、要有继承
			2、要有重写
			3、父类引用指向子类对象
形参和实参:
	形式参数:指的是方法声明时参数列表中的参数
	实际参数:指的是方法调用时实际传递的内容
	
构造方法：
	1、方法名和类名相同；
	2、构造方法没有返回值；	
	
	创建子类对象时，会先执行父类的构造方法，然后再执行子类的构造方法。	
	每一个类中都有一个空参的构造方法，当一个类B继承A类时，B类就会默认的调用A类中默认的空参构造方法
	如果A类中空参构造方法不再是空参也就是说有参数，那么就会报错，因此就可以用super(参数)来调用父
	类带参数的构造方法。

super关键字：父类对象，可以用super来调用父类的构造方法和属性。
this关键字:当前类对象

方法重载：
	表示在一个类中，包含多个方法名相同，但是参数列表不同的方法，参数列表不同指的是，参数类型
	参数个数，参数顺序不同。那么就是方法的重载；调用方法时通过传递不同的参数列表来具体决定使用哪个方法
	体现了一个类中的多态性。与返回值和权限修饰符无关。

方法重写：
	发生在父子类中，子类继承父类中的方法，但是子类修改了继承来的方法，也就是说子类进行了扩展
	那么这是重写。
构造方法的重载：
	方法名相同同（方法名与类名相同），参数列表不同，就是构造方法的重载。

变量:
	成员变量:成员变量又称实例变量，成员变量定义在类中，在整个类中都可以使用，成员变量随着对象的创建而存在
		随着对象的回收而销毁，成员变量有默认的初始值，成员变量储存在堆内存的对象中，只能被对象调用；
	局部变量：局部变量定义在局部范围，比如函数内或者语句内，只在所属范围内有效，局部变量存放在栈内存中，作用
		范围结束，变量空间就被释放了，没有初始值。
	静态变量(static修饰):静态变量又称类变量，当java虚拟机加载类的字节码文件时，类变量就存在了，随着类的存在
	而存在，静态变量储存在方法区(数据共享区)中的静态区，可以被类直接调用。

abstract:抽象的，没有具体的对象，指的是一个思维过程
		abstract修饰的类就是抽象类，抽象类不能直接实例化对象，只能由类继承这个抽象类，然后通过子类实例化对象
		来使用。
		没有方法体的方法就是抽象方法，抽象方法一定要有abstract关键字修饰。
		子类继承抽象类，必须重写抽象类中的所有抽象方法，除非子类也是抽象类。
final关键字:最终的，不可变的
	final修饰的属性不能被更改，成为常量
	final修饰的方法不能被重写
	final修饰的类不能被继承	
static关键字:
	static修饰的属性和方法储存在静态区，依赖类而不依赖于对象，可以被类直接调用
	静态方法中不能使用非静态的属性。	
接口:interface
	接口是一种规范一种规则。
	使用关键字interface创建一个接口  interface A{}，和class类同级
	接口中的方法都是抽象方法 public abstract void show();public和abstract可以不写，默认就有
	关键字implements:实现一个接口，如:public class B implements A{} B实现了A接口
	可以实现多个接口，用逗号隔开。接口中的属性都是静态的常量。
强制类型转换:
	抽象父类A的引用a指向了它的子类B对象，那么这个引用a就只能使用父类中的方法，不能使用子类中特有的方法，引用a
	要向使用子类中的方法，那么就要进行强制类型转换了	。为了避免转换过程发生转换异常，可以用关键字instanceof来
	进行判断是否是对应类型
	举例:
		抽象类A   B extends A;C extends A
		A a=new B();-----引用父类A的类型的引用a指向了子类B对象
		if(a instanceof B){
			B b=(B)a;------括号中就是要强转的类型
		}
类型转换异常:
	父类A的引用a指向了子类B的对象，现在要将引用a转换成子类C的引用c。这时就C类型的引用c指向了B类型的对象，这就
	会发生错误，因为这是不合理的，子类B和子类C并没有什么联系。
	举例:
		B extends A
		C extends A
		A a=new B();
		C c=a;
		两种类型不同，这是不合理的。	
	
	
	
	